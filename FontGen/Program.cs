using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Reflection;

namespace FontGen
{
    class Program
    {
        const int maxColors = 16;//Max for FB32 mode
        static Color[] palette = new Color[maxColors];
        static Dictionary<Color, int> paletteLookup = new Dictionary<Color, int>();
        const string paletteImageFile = "palette.png";
        //const int transparentColorIndex = Byte.MaxValue; //TODO: Add transparent support

        static Bitmap LoadImageOrPrintError(string filename)
        {
            try
            {
                return new Bitmap(filename);
            }
            catch (OutOfMemoryException)
            {
                Console.WriteLine("Could not load '{0}' because it is corrupted.", filename);
                Console.WriteLine();
                throw;
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("Could not load '{0}' because it could not be found.", filename);
                Console.WriteLine();
                throw;
            }
        }

        static void WriteHeader(StreamWriter f, string outputFile, string inputFile)
        {
            f.WriteLine("// {0} - automatically generated by {1} using {2}, do not edit this file directly!", outputFile, Assembly.GetExecutingAssembly().GetName().Name, inputFile);
        }

        static int Main(string[] args)
        {
            // Verify / parse arguments
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: FontGen input.png");
                Console.WriteLine();
                return 1;
            }

            string inputFile = args[0];//TODO: It'd be nice to be able to input a font file instead.
            string fontName = Path.GetFileNameWithoutExtension(inputFile);
            string FONTNAME = fontName.ToUpperInvariant();
            string outputFileCpp = Path.Combine(Path.GetDirectoryName(inputFile), fontName + ".gen.cpp");
            string outputFileHeader = Path.Combine(Path.GetDirectoryName(inputFile), fontName + ".gen.h");

            // Load the palette:
            using (Bitmap paletteImage = LoadImageOrPrintError(paletteImageFile))
            {
                if ((paletteImage.Width * paletteImage.Height) > palette.Length)
                {
                    Console.WriteLine("Palette image ({0}) is not a valid size! Width * Height must be less than or equal to {1}!", paletteImageFile, palette.Length);
                    return 1;
                }

                for (int y = 0; y < paletteImage.Height; y++)
                {
                    for (int x = 0; x < paletteImage.Width; x++)
                    {
                        int i = x + y * paletteImage.Width;
                        palette[i] = paletteImage.GetPixel(x, y);
                        paletteLookup[palette[i]] = i;
                    }
                }
            }

            // Output C++ file:
            int glyphWidth;
            int glyphHeight;
            string glyphs = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            int fontDataLength = 0;

            using (StreamWriter f = new StreamWriter(outputFileCpp))
            {
                // Output a header:
                WriteHeader(f, outputFileCpp, inputFile);
                f.WriteLine();
                f.WriteLine("#include \"{0}\"", outputFileHeader);
                f.WriteLine();

                // Write out the palette: //TODO: This tool needs to be more flexible so we can batch multiple images or do the palette separately.
                f.WriteLine("const unsigned char palette[PALETTE_SIZE] =");
                f.WriteLine("{");
                foreach (Color color in palette)
                {
                    f.WriteLine("    0x{0:X2},0x{1:X2},0x{2:X2},", color.R, color.G, color.B);
                }
                f.WriteLine("};");
                f.WriteLine();

                // Load the image:
                using (Bitmap inputImage = LoadImageOrPrintError(inputFile))
                {
                    // Check image width:
                    if ((inputImage.Height % glyphs.Length) != 0)
                    {
                        Console.WriteLine("Image must be a multiple of {0} pixels tall!", glyphs.Length);
                        return 1;
                    }

                    glyphWidth = inputImage.Width;
                    glyphHeight = inputImage.Height / glyphs.Length;

                    f.WriteLine("const unsigned char {0}[{1}_SIZE] = ", fontName, FONTNAME);
                    f.WriteLine("{");

                    // Read in the image and output each glyph:
                    //For simplicity's sake I'm not going to use LockBits since this tool doesn't need to be super performant for now.
                    //BitmapData bitmapData = inputImage.LockBits(new Rectangle(Point.Empty, inputImage.Size), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
                    for (int glyph = 0; glyph < glyphs.Length; glyph++)
                    {
                        f.WriteLine("    // '{0}'", glyphs[glyph]);

                        for (int y = glyph * glyphHeight; y < (glyph + 1) * glyphHeight; y++)
                        {
                            f.Write("    ");
                            for (int x = 0; x < glyphWidth; x++)
                            {
                                Color color = inputImage.GetPixel(x, y);
                                int colorIndex = 0;
                                if (!paletteLookup.TryGetValue(color, out colorIndex))
                                { Console.WriteLine("WARNING: Pixel at {0},{1} is not in the palette!", x, y); }

                                f.Write("0x{0:X2}, ", colorIndex);
                            }
                            f.WriteLine();
                        }

                        f.WriteLine();
                    }

                    f.WriteLine("};");
                }

                f.WriteLine();
            }

            // Output the header file:
            using (StreamWriter f = new StreamWriter(outputFileHeader))
            {
                WriteHeader(f, outputFileHeader, inputFile);
                f.WriteLine();
                f.WriteLine("#define PALETTE_COUNT {0}", palette.Length);
                f.WriteLine("#define PALETTE_SIZE (PALETTE_COUNT * 3)");
                f.WriteLine("extern const unsigned char palette[PALETTE_SIZE];");
                f.WriteLine();
                f.WriteLine("#define {0}_SIZE {1}", FONTNAME, glyphWidth * glyphHeight * glyphs.Length);
                f.WriteLine("#define {0}_GLYPH_WIDTH {1}", FONTNAME, glyphWidth);
                f.WriteLine("#define {0}_GLYPH_HEIGHT {1}", FONTNAME, glyphHeight);
                f.WriteLine("#define {0}_GLYPH_SIZE ({0}_GLYPH_WIDTH * {0}_GLYPH_HEIGHT)", FONTNAME);
                f.WriteLine("extern const unsigned char {0}[{1}_SIZE];", fontName, FONTNAME);
                f.WriteLine();
            }

            return 0;
        }
    }
}
