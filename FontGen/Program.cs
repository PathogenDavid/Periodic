using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Reflection;

namespace FontGen
{
    /// <summary>
    /// This program generates a pair of C++/header files that represent the data in a palette-indexed font file.
    /// It had to be created because the Sifteo tools do not include methods for generating images compatible with the frame buffer modes.
    /// The palette used is inferred from an image, which must be exactly <see cref="Program.maxColors"/> pixels. (Dimensions don't matter.)
    /// The font must have been prepared ahead of time in an image editing program. It is defined below:
    /// * Only fixed-width fonts are supported
    /// * Only letters are supported (uppercase and lower case)
    /// * The width image is expected to be the width of one character
    /// * The heigh of the image is expected to be the height of one character * 26 * 2
    /// * The order of the characters is A-Z followed by a-z
    /// 
    /// Obviously there are a lot of limitations right now.
    /// Updating the font generation tool to remove these constraints also involves updating the Sifteo-side code.
    /// </summary>
    class Program
    {
        /// <summary>The maximum number of colors in the palette</summary>
        const int maxColors = 16;//Max for FB32 mode

        /// <summary>The palette to use when generating the font</summary>
        static Color[] palette = new Color[maxColors];

        /// <summary>A reverse-lookup for <see cref="palette"/>.</summary>
        static Dictionary<Color, int> paletteLookup = new Dictionary<Color, int>();

        /// <summary>The file to use for the palette</summary>
        const string paletteImageFile = "palette.png";// TODO: Make this not hard-coded

        //TODO: Add transparent support
        ///// <summary>The value to use for transparent pixels</summary>
        //const int transparentColorIndex = Byte.MaxValue;

        /// <summary>
        /// Utility function for opening a handle to a bitmap, given its file name.
        /// Prints an error to the console before re-throwing any exceptions that occur when opening the handle.
        /// </summary>
        /// <param name="filename">The file path to the image to open</param>
        /// <returns>A bitmap handle to the specified image</returns>
        static Bitmap LoadImageOrPrintError(string filename)
        {
            try
            {
                return new Bitmap(filename);
            }
            catch (OutOfMemoryException)
            {
                Console.WriteLine("Could not load '{0}' because it is corrupted.", filename);
                Console.WriteLine();
                throw;
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("Could not load '{0}' because it could not be found.", filename);
                Console.WriteLine();
                throw;
            }
        }

        /// <summary>
        /// Writes a header comment to the specified output file.
        /// </summary>
        /// <param name="f">The file stream to output the header line to</param>
        /// <param name="outputFile">The name of the file this header will go into</param>
        /// <param name="inputFile">The name of the file used to generate this file</param>
        static void WriteHeader(StreamWriter f, string outputFile, string inputFile)
        {
            f.WriteLine("// {0} - automatically generated by {1} using {2}, do not edit this file directly!", outputFile, Assembly.GetExecutingAssembly().GetName().Name, inputFile);
        }

        /// <summary>
        /// Entry point for the font generation program.
        /// </summary>
        /// <param name="args">Command line arguments for this program. Currently only one is supported, the input file for the font.</param>
        /// <returns>An exit code for the program.</returns>
        static int Main(string[] args)
        {
            Console.WriteLine("FB32 Font File Generator for Sifteo Cubes");

            // Verify / parse arguments
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: FontGen input.png");
                Console.WriteLine();
                return 1;
            }

            string inputFile = args[0];//TODO: It'd be nice to be able to input a font file instead.
            string fontName = Path.GetFileNameWithoutExtension(inputFile);
            string FONTNAME = fontName.ToUpperInvariant();
            string outputFileCpp = Path.Combine(Path.GetDirectoryName(inputFile), fontName + ".gen.cpp");
            string outputFileHeader = Path.Combine(Path.GetDirectoryName(inputFile), fontName + ".gen.h");

            // Load the palette:
            using (Bitmap paletteImage = LoadImageOrPrintError(paletteImageFile))
            {
                if ((paletteImage.Width * paletteImage.Height) > palette.Length)
                {
                    Console.WriteLine("Palette image ({0}) is not a valid size! Width * Height must be less than or equal to {1}!", paletteImageFile, palette.Length);
                    return 1;
                }

                for (int y = 0; y < paletteImage.Height; y++)
                {
                    for (int x = 0; x < paletteImage.Width; x++)
                    {
                        int i = x + y * paletteImage.Width;
                        palette[i] = paletteImage.GetPixel(x, y);
                        paletteLookup[palette[i]] = i;
                    }
                }
            }

            // Output C++ file:
            int glyphWidth;
            int glyphHeight;
            string glyphs = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

            using (StreamWriter f = new StreamWriter(outputFileCpp))
            {
                // Output a header:
                WriteHeader(f, outputFileCpp, inputFile);
                f.WriteLine();
                f.WriteLine("#include \"{0}\"", outputFileHeader);
                f.WriteLine();

                // Write out the palette: //TODO: This tool needs to be more flexible so we can batch multiple images or do the palette separately.
                f.WriteLine("const unsigned char palette[PALETTE_SIZE] =");
                f.WriteLine("{");
                foreach (Color color in palette)
                {
                    f.WriteLine("    0x{0:X2},0x{1:X2},0x{2:X2},", color.R, color.G, color.B);
                }
                f.WriteLine("};");
                f.WriteLine();

                // Load the image:
                using (Bitmap inputImage = LoadImageOrPrintError(inputFile))
                {
                    // Check image width:
                    if ((inputImage.Height % glyphs.Length) != 0)
                    {
                        Console.WriteLine("Image must be a multiple of {0} pixels tall!", glyphs.Length);
                        return 1;
                    }

                    glyphWidth = inputImage.Width;
                    glyphHeight = inputImage.Height / glyphs.Length;

                    f.WriteLine("const unsigned char {0}[{1}_SIZE] = ", fontName, FONTNAME);
                    f.WriteLine("{");

                    // Read in the image and output each glyph:
                    //For simplicity's sake I'm not going to use LockBits since this tool doesn't need to be super performant for now.
                    //BitmapData bitmapData = inputImage.LockBits(new Rectangle(Point.Empty, inputImage.Size), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
                    for (int glyph = 0; glyph < glyphs.Length; glyph++)
                    {
                        f.WriteLine("    // '{0}'", glyphs[glyph]);

                        for (int y = glyph * glyphHeight; y < (glyph + 1) * glyphHeight; y++)
                        {
                            f.Write("    ");
                            for (int x = 0; x < glyphWidth; x++)
                            {
                                Color color = inputImage.GetPixel(x, y);
                                int colorIndex = 0;
                                if (!paletteLookup.TryGetValue(color, out colorIndex))
                                { Console.WriteLine("WARNING: Pixel at {0},{1} is not in the palette!", x, y); }

                                f.Write("0x{0:X2}, ", colorIndex);
                            }
                            f.WriteLine();
                        }

                        f.WriteLine();
                    }

                    f.WriteLine("};");
                }

                f.WriteLine();
            }

            // Output the header file:
            using (StreamWriter f = new StreamWriter(outputFileHeader))
            {
                WriteHeader(f, outputFileHeader, inputFile);
                string headerGuard = outputFileHeader.ToUpperInvariant().Replace('.', '_');
                f.WriteLine("#ifndef __{0}__", headerGuard);
                f.WriteLine("#define __{0}__", headerGuard);
                f.WriteLine();
                f.WriteLine("#define PALETTE_COUNT {0}", palette.Length);
                f.WriteLine("#define PALETTE_SIZE (PALETTE_COUNT * 3)");
                f.WriteLine("extern const unsigned char palette[PALETTE_SIZE];");
                f.WriteLine();
                f.WriteLine("#define {0}_SIZE {1}", FONTNAME, glyphWidth * glyphHeight * glyphs.Length);
                f.WriteLine("#define {0}_GLYPH_WIDTH {1}", FONTNAME, glyphWidth);
                f.WriteLine("#define {0}_GLYPH_HEIGHT {1}", FONTNAME, glyphHeight);
                f.WriteLine("#define {0}_GLYPH_SIZE ({0}_GLYPH_WIDTH * {0}_GLYPH_HEIGHT)", FONTNAME);
                f.WriteLine("extern const unsigned char {0}[{1}_SIZE];", fontName, FONTNAME);
                f.WriteLine();
                f.WriteLine("#endif");
                f.WriteLine();
            }

            return 0;
        }
    }
}
